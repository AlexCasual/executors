//
// thread_pool
// ~~~~~~~~~~~
// Simple thread pool.
//
// Copyright (c) 2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef EXECUTORS_EXPERIMENTAL_THREAD_POOL_HEADER
#define EXECUTORS_EXPERIMENTAL_THREAD_POOL_HEADER

#include <experimental/executor>
#include <experimental/bits/scheduler.h>
#include <thread>
#include <vector>

namespace std {
namespace experimental {

// Thread pool.

class thread_pool
  : public execution_context,
    private __scheduler
{
public:
  class executor;

  // construct / copy / destroy:

  thread_pool();
  explicit thread_pool(size_t __num_threads);
  thread_pool(const thread_pool&) = delete;
  thread_pool& operator=(const thread_pool&) = delete;
  ~thread_pool();

  // thread pool operations:

  void stop();
  void join();

private:
  friend executor make_executor(thread_pool& __p);
  vector<thread> _M_threads;
};

class thread_pool::executor
{
public:
  class work;

  // construct / copy / destroy:

  executor(const executor& __e);
  executor& operator=(const executor& __e);
  ~executor();

  // executor operations:

  template <class _Func> void post(_Func&& __f);
  template <class _Func> void dispatch(_Func&& __f);
  work make_work();
  template <class _Func> auto wrap(_Func&& __f);
  execution_context& context();

private:
  friend class thread_pool;
  friend executor make_executor(thread_pool& __p);
  friend executor make_executor(const executor& __e);
  friend executor make_executor(executor&& __e);
  friend executor make_executor(const work& __w);
  friend executor make_executor(work&& __w);
  explicit executor(thread_pool* __p) : _M_pool(__p) {}
  thread_pool* _M_pool;
};

template <> struct is_executor<thread_pool::executor> : true_type {};

class thread_pool::executor::work
{
public:
  work(const work& __w);
  work& operator=(const work& __w);
  ~work();

private:
  friend class executor;
  friend executor make_executor(const work& __w);
  friend executor make_executor(work&& __w);
  thread_pool* _M_pool;
  explicit work(thread_pool* __p);
};

thread_pool::executor make_executor(thread_pool& __s);
thread_pool::executor make_executor(const thread_pool&) = delete;
thread_pool::executor make_executor(thread_pool&&) = delete;
thread_pool::executor make_executor(const thread_pool::executor& __e);
thread_pool::executor make_executor(thread_pool::executor&& __e);
thread_pool::executor make_executor(const thread_pool::executor::work& __w);
thread_pool::executor make_executor(thread_pool::executor::work&& __w);

} // namespace experimental
} // namespace std

#include <experimental/bits/thread_pool.h>

#endif
