//
// timer
// ~~~~~
// Timer operations.
//
// Copyright (c) 2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef EXECUTORS_EXPERIMENTAL_TIMER_HEADER
#define EXECUTORS_EXPERIMENTAL_TIMER_HEADER

#include <chrono>
#include <experimental/executor>
#include <experimental/bits/timer_queue.h>
#include <system_error>

namespace std {
namespace experimental {
inline namespace concurrency_v1 {

template <class _Clock, class _Duration, class _CompletionToken>
  auto dispatch_at(const chrono::time_point<_Clock, _Duration>& __abs_time, _CompletionToken&& __token);
template <class _Clock, class _Duration, class _Executor, class _CompletionToken>
  auto dispatch_at(const chrono::time_point<_Clock, _Duration>& __abs_time,
    const _Executor& __e, _CompletionToken&& __token,
      typename enable_if<is_executor<_Executor>::value>::type* = 0);
template <class _Clock, class _Duration, class _ExecutionContext, class _CompletionToken>
  auto dispatch_at(const chrono::time_point<_Clock, _Duration>& __abs_time,
    _ExecutionContext& __c, _CompletionToken&& __token,
      typename enable_if<is_convertible<
        _ExecutionContext&, execution_context&>::value>::type* = 0);

template <class _Clock, class _Duration, class _CompletionToken>
  auto post_at(const chrono::time_point<_Clock, _Duration>& __abs_time, _CompletionToken&& __token);
template <class _Clock, class _Duration, class _Executor, class _CompletionToken>
  auto post_at(const chrono::time_point<_Clock, _Duration>& __abs_time,
    const _Executor& __e, _CompletionToken&& __token,
      typename enable_if<is_executor<_Executor>::value>::type* = 0);
template <class _Clock, class _Duration, class _ExecutionContext, class _CompletionToken>
  auto post_at(const chrono::time_point<_Clock, _Duration>& __abs_time,
    _ExecutionContext& __c, _CompletionToken&& __token,
      typename enable_if<is_convertible<
        _ExecutionContext&, execution_context&>::value>::type* = 0);

template <class _Clock, class _Duration, class _CompletionToken>
  auto defer_at(const chrono::time_point<_Clock, _Duration>& __abs_time, _CompletionToken&& __token);
template <class _Clock, class _Duration, class _Executor, class _CompletionToken>
  auto defer_at(const chrono::time_point<_Clock, _Duration>& __abs_time,
    const _Executor& __e, _CompletionToken&& __token,
      typename enable_if<is_executor<_Executor>::value>::type* = 0);
template <class _Clock, class _Duration, class _ExecutionContext, class _CompletionToken>
  auto defer_at(const chrono::time_point<_Clock, _Duration>& __abs_time,
    _ExecutionContext& __c, _CompletionToken&& __token,
      typename enable_if<is_convertible<
        _ExecutionContext&, execution_context&>::value>::type* = 0);

template <class _Rep, class _Period, class _CompletionToken>
auto dispatch_after(const chrono::duration<_Rep, _Period>& __rel_time, _CompletionToken&& __token);
template <class _Rep, class _Period, class _Executor, class _CompletionToken>
  auto dispatch_after(const chrono::duration<_Rep, _Period>& __rel_time,
    const _Executor& __e, _CompletionToken&& __token,
      typename enable_if<is_executor<_Executor>::value>::type* = 0);
template <class _Rep, class _Period, class _ExecutionContext, class _CompletionToken>
  auto dispatch_after(const chrono::duration<_Rep, _Period>& __rel_time,
    _ExecutionContext& __c, _CompletionToken&& __token,
      typename enable_if<is_convertible<
        _ExecutionContext&, execution_context&>::value>::type* = 0);

template <class _Rep, class _Period, class _CompletionToken>
auto post_after(const chrono::duration<_Rep, _Period>& __rel_time, _CompletionToken&& __token);
template <class _Rep, class _Period, class _Executor, class _CompletionToken>
  auto post_after(const chrono::duration<_Rep, _Period>& __rel_time,
    const _Executor& __e, _CompletionToken&& __token,
      typename enable_if<is_executor<_Executor>::value>::type* = 0);
template <class _Rep, class _Period, class _ExecutionContext, class _CompletionToken>
  auto post_after(const chrono::duration<_Rep, _Period>& __rel_time,
    _ExecutionContext& __c, _CompletionToken&& __token,
      typename enable_if<is_convertible<
        _ExecutionContext&, execution_context&>::value>::type* = 0);

template <class _Rep, class _Period, class _CompletionToken>
auto defer_after(const chrono::duration<_Rep, _Period>& __rel_time, _CompletionToken&& __token);
template <class _Rep, class _Period, class _Executor, class _CompletionToken>
  auto defer_after(const chrono::duration<_Rep, _Period>& __rel_time,
    const _Executor& __e, _CompletionToken&& __token,
      typename enable_if<is_executor<_Executor>::value>::type* = 0);
template <class _Rep, class _Period, class _ExecutionContext, class _CompletionToken>
  auto defer_after(const chrono::duration<_Rep, _Period>& __rel_time,
    _ExecutionContext& __c, _CompletionToken&& __token,
      typename enable_if<is_convertible<
        _ExecutionContext&, execution_context&>::value>::type* = 0);

} // inline namespace concurrency_v1
} // namespace experimental
} // namespace std

#include <experimental/bits/dispatch_at.h>
#include <experimental/bits/dispatch_after.h>
#include <experimental/bits/post_at.h>
#include <experimental/bits/post_after.h>
#include <experimental/bits/defer_at.h>
#include <experimental/bits/defer_after.h>

#endif
