//
// executor
// ~~~~~~~~
// Asynchronous model and generic executor utility functions.
//
// Copyright (c) 2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef EXECUTORS_EXPERIMENTAL_EXECUTOR_HEADER
#define EXECUTORS_EXPERIMENTAL_EXECUTOR_HEADER

#include <experimental/bits/associated_allocator.h>
#include <experimental/bits/associated_executor.h>
#include <experimental/bits/executor_binder_base.h>
#include <future>
#include <memory>
#include <mutex>
#include <scoped_allocator>
#include <typeinfo>
#include <utility>

namespace std {
namespace experimental {
inline namespace concurrency_v2 {

class __executor_impl_base;
template <class> class __executor_impl;
template <class, class> struct __packaged_token;

// Trait used to obtain an object's associated allocator.

template <class _T, class _Alloc = allocator<void>>
struct associated_allocator
{
  typedef typename __associated_allocator<_T, _Alloc>::_Type type;

  static type get(const _T& __t, const _Alloc& __a = _Alloc()) noexcept
  {
    return __associated_allocator<_T, _Alloc>::_Get(__t, __a);
  }
};

template <class _T, class _Alloc = allocator<void>>
using associated_allocator_t = typename associated_allocator<_T, _Alloc>::type;

// Helper function to obtain an associated allocator.

template <class _T>
  associated_allocator_t<_T> get_associated_allocator(const _T& __t);
template <class _T, class _Alloc>
  associated_allocator_t<_T, _Alloc>
    get_associated_allocator(const _T& __t, const _Alloc& __a);

// Trait to determine the return type and value of an asynchronous operation.

template <class _CompletionToken, class _Signature>
class async_result
{
public:
  typedef _CompletionToken completion_handler_type;
  typedef void return_type;
  explicit async_result(completion_handler_type&) {}
  async_result(const async_result&) = delete;
  async_result& operator=(const async_result&) = delete;
  void get() {}
};

// Helper to determine the return type and value of an asynchronous operation.

template <class _CompletionToken, class _Signature>
struct async_completion
{
  typedef typename async_result<typename decay<_CompletionToken>::type,
    _Signature>::completion_handler_type completion_handler_type;

  explicit async_completion(_CompletionToken& __token)
    : completion_handler(static_cast<typename conditional<
        is_same<_CompletionToken, completion_handler_type>::value,
        completion_handler_type&, _CompletionToken&&>::type>(__token)),
      result(completion_handler) {}

  async_completion(const async_completion&) = delete;
  async_completion& operator=(const async_completion&) = delete;

  typename conditional<
    is_same<_CompletionToken, completion_handler_type>::value,
    completion_handler_type&, completion_handler_type>::type completion_handler;

  async_result<typename decay<_CompletionToken>::type, _Signature> result;
};

class system_executor;

// Execution context.

enum class fork_event
{
  prepare,
  parent,
  child
};

class execution_context
{
public:
  class service;

  // construct / copy / destroy:

  execution_context();
  execution_context(const execution_context&) = delete;
  execution_context& operator=(const execution_context&) = delete;
  virtual ~execution_context();

  // execution context operations:

  void notify_fork(fork_event __e);

protected:

  // execution context protected operations:

  void shutdown() noexcept;
  void destroy() noexcept;

private:
  template <class _Service> friend _Service& use_service(execution_context& __c);
  template <class _Service, class... _Args> friend _Service&
    make_service(execution_context& __c, _Args&&... __args);
  template <class _Service> bool friend has_service(execution_context& __c) noexcept;
  mutex _M_mutex;
  service* _M_first_service;
};

// Base class for all services within an execution context.

class execution_context::service
{
protected:
  explicit service(execution_context& __c);
  virtual ~service();

  execution_context& context() noexcept;

private:
  friend class execution_context;

  virtual void shutdown() noexcept = 0;
  virtual void notify_fork(fork_event __e);

  template <class _Service> friend _Service& use_service(execution_context& __c);
  template <class _Service, class... _Args> friend _Service&
    make_service(execution_context& __c, _Args&&... __args);
  template <class _Service> bool friend has_service(execution_context& __c) noexcept;
  friend struct default_delete<service>;
  execution_context& _M_context;
  const type_info* _M_id;
  service* _M_next;
  bool _M_shutdown;
};

// Functions for accessing the services within an execution context.

class service_already_exists;

template <class _Service> _Service& use_service(execution_context& __c);
template <class _Service, class... _Args> _Service&
  make_service(execution_context& __c, _Args&&... __args);
template <class _Service> bool has_service(execution_context& __c) noexcept;

// The is_executor trait detects whether _T meets the Executor type
// requirements. Meets the UnaryTypeTrait requirements. The implementation
// shall provide a definition that is derived from false_type. A program may
// specialize this template to derive from true_type for a user-defined type _T
// the meets the Executor requirements.

template <class _T> struct is_executor : false_type {};

// The executor_arg_t struct is an empty structure type used as a unique type
// to disambiguate constructor and function overloading. Specifically, some
// types have constructors with executor_arg_t as the first argument,
// immediately followed by an argument of a type that satisfies the Executor
// requirements.

struct executor_arg_t {};

#if defined(_MSC_VER)
__declspec(selectany) executor_arg_t executor_arg = executor_arg_t{};
#else
constexpr executor_arg_t executor_arg = executor_arg_t{};
#endif

// The uses_executor trait detects whether _T has an associated executor that
// is convertible from type _Executor. Meets the BinaryTypeTrait requirements.
// The implementation shall provide a definition that is derived from
// false_type. A program may specialize this template to derive from true_type
// for a user-defined type _T that can be constructed with an executor, where
// the first argument of a constructor has type executor_arg_t and the second
// argument is convertible from type _Executor.

template <class _T, class _Executor> struct uses_executor : false_type {};

// Trait used to obtain an object's associated allocator.

template <class _T, class _Executor = system_executor>
struct associated_executor
{
  typedef typename __associated_executor<_T, _Executor>::_Type type;

  static type get(const _T& __t, const _Executor& __a = _Executor()) noexcept
  {
    return __associated_executor<_T, _Executor>::_Get(__t, __a);
  }
};

template <class _T, class _Executor = system_executor>
using associated_executor_t = typename associated_executor<_T, _Executor>::type;

// A call wrapper type to bind an executor of type _Executor to an object of
// type _T.

template <class _T, class _Executor>
class executor_binder
  : public __executor_binder_base_executor<_Executor>,
    public __executor_binder_base_target<_T>
{
public:
  typedef _T target_type;
  typedef _Executor executor_type;

  // construct / copy / destroy:

  executor_binder(_T __t, const _Executor& __ex);
  executor_binder(const executor_binder& __w) = default;
  executor_binder(executor_binder&& __w) = default;
  template <class _U, class _OtherExecutor>
    executor_binder(const executor_binder<_U, _OtherExecutor>& __w);
  template <class _U, class _OtherExecutor>
    executor_binder(executor_binder<_U, _OtherExecutor>&& __w);
  template <class _U, class _OtherExecutor>
    executor_binder(executor_arg_t, const _Executor& __ex,
      const executor_binder<_U, _OtherExecutor>& __w);
  template <class _U, class _OtherExecutor>
    executor_binder(executor_arg_t, const _Executor& __ex,
      executor_binder<_U, _OtherExecutor>&& __w);

  ~executor_binder();

  // executor binder operations:

  _T& get() noexcept;
  const _T& get() const noexcept;
  executor_type get_executor() const noexcept;

  template <class... _Args>
    typename result_of<_T&(_Args&&...)>::type
      operator()(_Args&&... __args);
  template <class... _Args>
    typename result_of<const _T&(_Args&&...)>::type
      operator()(_Args&&... __args) const;

private:
  template <class _U, class _E> friend class executor_binder;
  template <class _E, class _U> executor_binder(int, _E&& __e, _U&& __u);
  template <class _E, class _U> executor_binder(_E&& __e, _U&& __u, true_type);
  template <class _E, class _U> executor_binder(_E&& __e, _U&& __u, false_type);
};

template <class _T, class _Executor>
  struct uses_executor<executor_binder<_T, _Executor>, _Executor> : true_type {};

template <class _T, class _Executor, class _Signature>
  class async_result<executor_binder<_T, _Executor>, _Signature>;

template <class _T, class _Executor, class _Alloc>
  struct associated_allocator<executor_binder<_T, _Executor>, _Alloc>;

template <class _T, class _Executor, class _Executor1>
  struct associated_executor<executor_binder<_T, _Executor>, _Executor1>;

// Helper function to associate an executor with an object.

template <class _Executor, class _T>
  executor_binder<typename decay<_T>::type, _Executor>
    bind_executor(const _Executor& __e, _T&& __t,
      typename enable_if<is_executor<_Executor>::value>::type* = 0);

template <class _ExecutionContext, class _T>
  executor_binder<typename decay<_T>::type, typename _ExecutionContext::executor_type>
    bind_executor(_ExecutionContext& __c, _T&& __t,
      typename enable_if<is_convertible<
        _ExecutionContext&, execution_context&>::value>::type* = 0);

// Helper function to obtain an associated executor.

template <class _T>
  associated_executor_t<_T> get_associated_executor(const _T& __t);
template <class _T, class _Executor>
  associated_executor_t<_T, _Executor>
    get_associated_executor(const _T& __t, const _Executor& __e,
      typename enable_if<is_executor<_Executor>::value>::type* = 0);
template <class _T, class _ExecutionContext>
  associated_executor_t<_T, typename _ExecutionContext::executor_type>
    get_associated_executor(const _T& __t, _ExecutionContext& __c,
      typename enable_if<is_convertible<_ExecutionContext&, execution_context&>::value>::type* = 0);

// An object of class executor_work controls ownership of executor work within
// a scope.

template <class _Executor>
class executor_work
{
public:
  typedef _Executor executor_type;

  // construct / copy / destroy:

  explicit executor_work(const executor_type& __e) noexcept;
  executor_work(const executor_work& __w) noexcept;
  executor_work(executor_work&& __w) noexcept;

  executor_work operator=(const executor_type&) = delete;

  ~executor_work();

  // executor work observers:

  executor_type get_executor() const noexcept;
  bool owns_work() const noexcept;

  // executor work modifiers:

  void reset() noexcept;

private:
  executor_type _M_executor;
  bool _M_owns;
};

// Helper function to create work for an executor, execution context or object.

template <class _Executor>
  executor_work<_Executor> make_work(const _Executor& __e,
    typename enable_if<is_executor<_Executor>::value>::type* = 0);
template <class _ExecutionContext>
  executor_work<typename _ExecutionContext::executor_type> make_work(_ExecutionContext& __c,
    typename enable_if<is_convertible<_ExecutionContext&, execution_context&>::value>::type* = 0);
template <class _T>
  executor_work<associated_executor_t<_T>> make_work(const _T& __t,
    typename enable_if<!is_executor<_T>::value &&
      !is_convertible<_T&, execution_context&>::value>::type* = 0);
template <class _T, class _Executor>
  executor_work<associated_executor_t<_T, _Executor>> make_work(const _T& __t, const _Executor& __e,
    typename enable_if<is_executor<_Executor>::value>::type* = 0);
template <class _T, class _ExecutionContext>
  executor_work<associated_executor_t<_T, typename _ExecutionContext::executor_type>>
    make_work(const _T& __t, _ExecutionContext& __c,
      typename enable_if<is_convertible<_ExecutionContext&, execution_context&>::value>::type* = 0);

// The system executor represents an execution context where functions are
// permitted to run on arbitrary threads. The post() function schedules the
// function to run on an unspecified system thread pool, and dispatch() invokes
// the function immediately.

class system_executor
{
public:
  system_executor() {}

  // executor operations:

  execution_context& context() noexcept;

  void on_work_started() noexcept;
  void on_work_finished() noexcept;

  template <class _Func, class _Alloc>
    void dispatch(_Func&& __f, const _Alloc& a);
  template <class _Func, class _Alloc>
    void post(_Func&& __f, const _Alloc& a);
  template <class _Func, class _Alloc>
    void defer(_Func&& __f, const _Alloc& a);
};

bool operator==(const system_executor&, const system_executor&) noexcept;
bool operator!=(const system_executor&, const system_executor&) noexcept;

template <> struct is_executor<system_executor> : true_type {};

class bad_executor;

// Polymorphic executor wrapper.

class executor
{
public:
  // construct / copy / destroy:

  executor() noexcept;
  executor(nullptr_t) noexcept;
  executor(const executor& __e) noexcept;
  executor(executor&& __e) noexcept;
  template <class _Executor> executor(_Executor __e);
  template <class _Executor, class _Alloc>
    executor(allocator_arg_t, const _Alloc& __a, _Executor __e);

  executor& operator=(const executor& __e) noexcept;
  executor& operator=(executor&& __e) noexcept;
  executor& operator=(nullptr_t) noexcept;
  template <class _Executor> executor& operator=(_Executor __e);

  ~executor();

  // executor operations:

  execution_context& context() noexcept;

  void on_work_started() noexcept;
  void on_work_finished() noexcept;

  template <class _Func, class _Alloc>
    void dispatch(_Func&& __f, const _Alloc& a);
  template <class _Func, class _Alloc>
    void post(_Func&& __f, const _Alloc& a);
  template <class _Func, class _Alloc>
    void defer(_Func&& __f, const _Alloc& a);

  // executor capacity:

  explicit operator bool() const noexcept;

  // executor target access:

  const type_info& target_type() const noexcept;
  template <class _Executor> _Executor* target() noexcept;
  template <class _Executor> const _Executor* target() const noexcept;

private:
  friend bool operator==(const executor&, const executor&) noexcept;
  explicit executor(__executor_impl_base* __i) : _M_impl(__i) {}
  __executor_impl_base* _M_impl;
};

template <> struct is_executor<executor> : true_type {};

bool operator==(const executor& __a, const executor& __b) noexcept;
bool operator==(const executor& __e, nullptr_t) noexcept;
bool operator==(nullptr_t, const executor& __e) noexcept;
bool operator!=(const executor& __a, const executor& __b) noexcept;
bool operator!=(const executor& __e, nullptr_t) noexcept;
bool operator!=(nullptr_t, const executor& __e) noexcept;

// Schedule a function to run now if possible, later otherwise.

template <class _CompletionToken> auto dispatch(_CompletionToken&& __token);
template <class _Executor, class _CompletionToken>
  auto dispatch(const _Executor& __e, _CompletionToken&& __token,
    typename enable_if<is_executor<_Executor>::value>::type* = 0);
template <class _ExecutionContext, class _CompletionToken>
  auto dispatch(_ExecutionContext& __c, _CompletionToken&& __token,
    typename enable_if<is_convertible<_ExecutionContext&, execution_context&>::value>::type* = 0);

// Schedule a function to run later.

template <class _CompletionToken> auto post(_CompletionToken&& __token);
template <class _Executor, class _CompletionToken>
  auto post(const _Executor& __e, _CompletionToken&& __token,
    typename enable_if<is_executor<_Executor>::value>::type* = 0);
template <class _ExecutionContext, class _CompletionToken>
  auto post(_ExecutionContext& __c, _CompletionToken&& __token,
    typename enable_if<is_convertible<_ExecutionContext&, execution_context&>::value>::type* = 0);

// Schedule a function to run later, treating the function as a continuation of the caller.

template <class _CompletionToken> auto defer(_CompletionToken&& __token);
template <class _Executor, class _CompletionToken>
  auto defer(const _Executor& __e, _CompletionToken&& __token,
    typename enable_if<is_executor<_Executor>::value>::type* = 0);
template <class _ExecutionContext, class _CompletionToken>
  auto defer(_ExecutionContext& __c, _CompletionToken&& __token,
    typename enable_if<is_convertible<_ExecutionContext&, execution_context&>::value>::type* = 0);

struct __strand_impl;

template <class _Executor>
class strand
{
public:
  typedef _Executor inner_executor_type;

  // construct / copy / destroy:

  template <class _Dummy = int> strand(_Dummy = 0,
    typename enable_if<is_default_constructible<_Executor>::value, _Dummy>::type* = 0);
  explicit strand(_Executor __e);
  strand(const strand& __s);
  strand(strand&& __s);
  template <class _OtherExecutor> strand(const strand<_OtherExecutor>& __s);
  template <class _OtherExecutor> strand(strand<_OtherExecutor>&& __s);

  strand& operator=(const strand& __s);
  strand& operator=(strand&& __s);
  template <class _OtherExecutor> strand& operator=(const strand<_OtherExecutor>& __s);
  template <class _OtherExecutor> strand& operator=(strand<_OtherExecutor>&& __s);

  ~strand();

  // executor operations:

  inner_executor_type get_inner_executor() const noexcept;

  bool running_in_this_thread() const noexcept;

  execution_context& context() noexcept;

  void on_work_started() noexcept;
  void on_work_finished() noexcept;

  template <class _Func, class _Alloc>
    void dispatch(_Func&& __f, const _Alloc& a);
  template <class _Func, class _Alloc>
    void post(_Func&& __f, const _Alloc& a);
  template <class _Func, class _Alloc>
    void defer(_Func&& __f, const _Alloc& a);

private:
  template <class> friend class strand;
  template <class _E> friend bool operator==(const strand<_E>&, const strand<_E>&) noexcept;
  friend class work;
  strand(const _Executor& __e, const shared_ptr<__strand_impl>& __i);
  _Executor _M_executor;
  shared_ptr<__strand_impl> _M_impl;
};

template <class _Executor>
  bool operator==(const strand<_Executor>& __a, const strand<_Executor>& __b) noexcept;
template <class _Executor>
  bool operator!=(const strand<_Executor>& __a, const strand<_Executor>& __b) noexcept;

template <class _Executor> struct is_executor<strand<_Executor>> : true_type {};

// The class template use_future_t defines a set of completion token types for
// use with asynchronous operations.

template <class _Alloc = allocator<void>>
class use_future_t
{
public:
  typedef _Alloc allocator_type;

#if defined(_MSC_VER)
  use_future_t() noexcept
  {
  }
#else
  constexpr use_future_t() noexcept
  {
  }
#endif

  explicit use_future_t(const _Alloc& __a) noexcept
    : _M_allocator(__a)
  {
  }

  template <class _OtherAllocator>
  use_future_t<_OtherAllocator> rebind(
    const _OtherAllocator& __a) const noexcept
  {
    return use_future_t<_OtherAllocator>(__a);
  }

  allocator_type get_allocator() const noexcept
  {
    return _M_allocator;
  }

  template <class _F>
    __packaged_token<typename decay<_F>::type, allocator_type>
      operator()(_F&& __f) const;

private:
  allocator_type _M_allocator;
};

#if defined(_MSC_VER)
__declspec(selectany) use_future_t<> use_future;
#else
constexpr use_future_t<> use_future;
#endif

template <class _Alloc, class _R, class... _Args>
  class async_result<use_future_t<_Alloc>, _R(_Args...)>;

// Support for packaged_task<>.

template <class _R, class... _Args, class _Signature>
  class async_result<packaged_task<_R(_Args...)>, _Signature>;

} // inline namespace concurrency_v2
} // namespace experimental

template<class _Alloc>
  struct uses_allocator<std::experimental::executor, _Alloc>
    : true_type {};

} // namespace std

#include <experimental/bits/get_associated_allocator.h>
#include <experimental/bits/execution_context.h>
#include <experimental/bits/system_executor.h>
#include <experimental/bits/executor_binder.h>
#include <experimental/bits/bind_executor.h>
#include <experimental/bits/get_associated_executor.h>
#include <experimental/bits/executor_work.h>
#include <experimental/bits/make_work.h>
#include <experimental/bits/executor.h>
#include <experimental/bits/dispatch.h>
#include <experimental/bits/post.h>
#include <experimental/bits/defer.h>
#include <experimental/bits/strand.h>
#include <experimental/bits/use_future.h>
#include <experimental/bits/packaged_task.h>

#endif
