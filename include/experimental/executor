//
// executor
// ~~~~~~~~
// Polymorphic executor wrapper and generic executor utility functions.
//
// Copyright (c) 2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef EXECUTORS_EXPERIMENTAL_EXECUTOR_HEADER
#define EXECUTORS_EXPERIMENTAL_EXECUTOR_HEADER

#include <experimental/bits/executor_wrapper_base.h>
#include <experimental/bits/function_traits.h>
#include <memory>
#include <mutex>
#include <scoped_allocator>
#include <typeinfo>
#include <utility>

namespace std {
namespace experimental {
inline namespace concurrency_v1 {

template <class, class = void> struct __get_executor_impl;

class __executor_impl_base;
template <class> class __executor_impl;

template <class...> struct __invoke_with_token;
template <class, class...> struct __invoke_with_executor;
template <class, class...> struct __invoke_with_execution_context;
template <class...> struct __coinvoke_without_executor;
template <class, class...> struct __coinvoke_with_executor;

// The handler_type trait is used to determine the handler type for an
// asynchronous operation. A handler is a function object ([function.objects])
// that is invoked on completion of the operation.
//
// Template parameter _CompletionToken specifies the model used to obtain the
// result of the asynchronous operation. Template parameter _Signature is the
// call signature ([func.def]) for the handler type invoked on completion of
// the asynchronous operation.
//
// A program may specialize this trait if the _CompletionToken template
// parameter in the specialization is a user-defined type.
//
// Specializations of handler_type shall define a nested handler type, named
// type, that satisifies the MoveConstructible requirements, and objects of
// type type shall be constructible from an lvalue or rvalue of the type
// specified by the _CompletionToken template parameter.

template <class _CompletionToken, class _Signature, class = void>
struct handler_type
{
  // Type: _CompletionToken if _CompletionToken and
  // decay<_CompletionToken>::type are the same type; otherwise,
  // handler_type<typename decay<_CompletionToken>::type, _Signature>::type.
  typedef typename conditional<
    is_same<_CompletionToken, typename decay<_CompletionToken>::type>::value,
    decay<_CompletionToken>,
    handler_type<typename decay<_CompletionToken>::type, _Signature>
  >::type::type type;
};

template <class _CompletionToken, class _Signature>
using handler_type_t = typename handler_type<
  _CompletionToken, _Signature>::type;

// The async_result trait enables customization of the return type and return
// value of an asynchronous operationâ€™s initiating function.
//
// Template argument _Handler is a handler type produced by handler_type<T,
// S>::type for some completion token type T and call signature S.
//
// A program may specialize this template if the _Handler template parameter in
// the specialization is a user-defined type.
//
// Specializations of async_result shall satisfy the Destructible requirements
// in addition to the requirements in the table below. In this table, R is a
// specialization of async_result for the template parameter _Handler; r is a
// modifiable lvalue of type R; and h is a modifiable lvalue of type _Handler.
//
// +--------------------------------------------------------------------------+
// | Expression       Return type        Note                                 |
// +--------------------------------------------------------------------------+
// | R::type                             void; or a type satisfying           |
// |                                     MoveConstructible requirements.      |
// +--------------------------------------------------------------------------+
// | R r(h);                                                                  |
// +--------------------------------------------------------------------------+
// | r.get()          R::type            The get() member function shall      |
// |                                     be used only as a return expression. |
// +--------------------------------------------------------------------------+

template <class _Handler>
class async_result
{
public:
  typedef void type;
  explicit async_result(_Handler&) {}
  async_result(const async_result&) = delete;
  async_result& operator=(const async_result&) = delete;
  void get() {}
};

// The async_completion template may be used within an initiating function to
// reify a completion token into a handler and its linked asynchronous result.
//
// Template parameter _CompletionToken specifies the model used to obtain the
// result of the asynchronous operation. Template parameter _Signature is the
// call signature ([func.def]) for the handler type invoked on completion of
// the asynchronous operation.

template <class _CompletionToken, class _Signature>
struct async_completion
{
  typedef handler_type_t<_CompletionToken, _Signature> handler_type;

  explicit async_completion(
    typename remove_reference<_CompletionToken>::type& __token)
    : handler(static_cast<typename conditional<
        is_same<_CompletionToken, handler_type>::value,
        handler_type&, _CompletionToken&&>::type>(__token)),
      result(handler) {}

  async_completion(const async_completion&) = delete;
  async_completion& operator=(const async_completion&) = delete;

  typename conditional<
    is_same<_CompletionToken, handler_type>::value,
    handler_type&, handler_type>::type handler;

  async_result<handler_type> result;
};

template <class> struct continuation_of; // Not defined.

// The continuation_of template enables customisation of function invocation
// and passing of the result to a continuation.
//
// A program may specialize this template if the _Func template parameter in
// the specialization is a user-defined type.
//
// Specializations of continuation_of shall satisfy the requirements in the
// table below. In this table, C is the template specialization
// continuation_of<_Func(_Args...)>; f is an lvalue or rvalue of type _Func;
// and c is an lvalue or rvalue of function object type meeting
// MoveConstructible requirements and callable with an argument of type
// C::result_type.
//
// +--------------------------------------------------------------------------+
// | Expression       Return type         Note                                |
// +--------------------------------------------------------------------------+
// | C::signature                         The required signature for a        |
// |                                      function object that receives the   |
// |                                      result of a function of type _Func. |
// |                                      when invoked with arguments _Args.  |
// +--------------------------------------------------------------------------+
// | C::chain(f, c)   Function object                                         |
// |                  type meeting                                            |
// |                  MoveConstructible                                       |
// |                  requirements and                                        |
// |                  callable with the                                       |
// |                  same arguments as                                       |
// |                  f.                                                      |
// +--------------------------------------------------------------------------+

template <class _Func, class... _Args>
struct continuation_of<_Func(_Args...)>
{
  // Type:
  //
  // - If _Func and decay<_Func>::type are different types,
  //   continuation_of<typename decay<_Func>::type(_Args...)>::signature;
  //
  // - Let _R be the type produced by typename result_of<_Func(_Args...)>::type.
  //   If _R is void, void(). If _R is non-void, void(_R).
  //
  // - Otherwise, if result_of<_Func(_Args...)> does not contain a nested type
  //   named type, the program is ill-formed.
  typedef typename conditional<
    is_same<_Func, typename decay<_Func>::type>::value,
    __function_continuation_of<_Func, _Args...>,
    continuation_of<typename decay<_Func>::type(_Args...)>
  >::type::signature signature;

  // If _Func and decay<_Func>::type are different types, returns
  // continuation_of<typename decay<_Func>::type>::chain(forward<_F>(__f),
  // forward<_Continuation>(__c)). Otherwise, returns a function object that,
  // when invoked, calls a copy of __f, and then passes the result to a copy of
  // __c.
  template <class _F, class _Continuation>
  static auto chain(_F&& __f, _Continuation&& __c)
  {
    return continuation_of::_Chain(
      is_same<_Func, typename decay<_Func>::type>(),
        forward<_F>(__f), forward<_Continuation>(__c));
  }

private:
  template <class _F, class _Continuation>
  static auto _Chain(true_type, _F&& __f, _Continuation&& __c)
  {
    return __chain<_Func, __signature_t<_Func>,
      typename decay<_Continuation>::type>(
        forward<_F>(__f), forward<_Continuation>(__c));
  }

  template <class _F, class _Continuation>
  static auto _Chain(false_type, _F&& __f, _Continuation&& __c)
  {
    return continuation_of<typename decay<_Func>::type>::chain(
      forward<_F>(__f), forward<_Continuation>(__c));
  }
};

// Execution context.

enum class fork_event
{
  prepare,
  parent,
  child
};

class execution_context
{
public:
  class service;

  // construct / copy / destroy:

  execution_context();
  execution_context(const execution_context&) = delete;
  execution_context& operator=(const execution_context&) = delete;
  virtual ~execution_context();

  // execution context operations:

  void notify_fork(fork_event __e);

protected:

  // execution context protected operations:

  void shutdown_context();
  void destroy_context();

private:
  template <class _Service> friend _Service& use_service(execution_context& __c);
  template <class _Service, class... _Args> friend _Service&
    make_service(execution_context& __c, _Args&&... __args);
  template <class _Service> bool friend has_service(execution_context& __c) noexcept;
  mutex _M_mutex;
  service* _M_first_service;
};

// Base class for all services within an execution context.

class execution_context::service
{
protected:
  explicit service(execution_context& __c);
  virtual ~service();

  execution_context& context() noexcept;

private:
  friend class execution_context;

  virtual void shutdown_service() = 0;
  virtual void notify_fork(fork_event __e);

  template <class _Service> friend _Service& use_service(execution_context& __c);
  template <class _Service, class... _Args> friend _Service&
    make_service(execution_context& __c, _Args&&... __args);
  template <class _Service> bool friend has_service(execution_context& __c) noexcept;
  friend struct default_delete<service>;
  execution_context& _M_context;
  const type_info* _M_id;
  service* _M_next;
};

// Functions for accessing the services within an execution context.

class service_already_exists;

template <class _Service> _Service& use_service(execution_context& __c);
template <class _Service, class... _Args> _Service&
  make_service(execution_context& __c, _Args&&... __args);
template <class _Service> bool has_service(execution_context& __c) noexcept;

// The is_executor trait detects whether _T meets the Executor type
// requirements. Meets the UnaryTypeTrait requirements. The implementation
// shall provide a definition that is derived from false_type. A program may
// specialize this template to derive from true_type for a user-defined type _T
// the meets the Executor requirements.

template <class _T> struct is_executor : false_type {};

// The executor_arg_t struct is an empty structure type used as a unique type
// to disambiguate constructor and function overloading. Specifically, some
// types have constructors with executor_arg_t as the first argument,
// immediately followed by an argument of a type that satisfies the Executor
// requirements.

struct executor_arg_t {};
constexpr executor_arg_t executor_arg = executor_arg_t{};

// The uses_executor trait detects whether _T has an associated executor that
// is convertible from type _Executor. Meets the BinaryTypeTrait requirements.
// The implementation shall provide a definition that is derived from
// false_type. A program may specialize this template to derive from true_type
// for a user-defined type _T that can be constructed with an executor, where
// the first argument of a constructor has type executor_arg_t and the second
// argument is convertible from type _Executor.

template <class _T, class _Executor> struct uses_executor : false_type {};

// A call wrapper type to associate an object of type _T with an executor of
// type _Executor.

template <class _T, class _Executor>
class executor_wrapper
  : public __executor_wrapper_base_executor<_Executor>,
    public __executor_wrapper_base_wrapped<_T>
{
public:
  typedef _T wrapped_type;
  typedef _Executor executor_type;
  // typedef ... result_type;
  // typedef ... argument_type;
  // typedef ... first_argument_type;
  // typedef ... second_argument_type;

  // construct / copy / destroy:

  executor_wrapper(_T __t, const _Executor& __ex);
  executor_wrapper(const executor_wrapper& __w) = default;
  executor_wrapper(executor_wrapper&& __w) = default;
  template <class _U, class _OtherExecutor>
    executor_wrapper(const executor_wrapper<_U, _OtherExecutor>& __w);
  template <class _U, class _OtherExecutor>
    executor_wrapper(executor_wrapper<_U, _OtherExecutor>&& __w);
  template <class _U, class _OtherExecutor>
    executor_wrapper(executor_arg_t, const _Executor& __ex,
      const executor_wrapper<_U, _OtherExecutor>& __w);
  template <class _U, class _OtherExecutor>
    executor_wrapper(executor_arg_t, const _Executor& __ex,
      executor_wrapper<_U, _OtherExecutor>&& __w);

  ~executor_wrapper();

  // executor wrapper operations:

  _T& unwrap() noexcept;
  const _T& unwrap() const noexcept;
  executor_type get_executor() const noexcept;

  template <class... _Args>
    typename result_of<_T&(_Args&&...)>::type
      operator()(_Args&&... __args) &;
  template <class... _Args>
    typename result_of<const _T&(_Args&&...)>::type
      operator()(_Args&&... __args) const &;
  template <class... _Args>
    typename result_of<_T&&(_Args&&...)>::type
      operator()(_Args&&... __args) &&;
  template <class... _Args>
    typename result_of<const _T&&(_Args&&...)>::type
      operator()(_Args&&... __args) const &&;

private:
  template <class _U, class _E> friend class executor_wrapper;
  template <class _E, class _U> executor_wrapper(int, _E&& __e, _U&& __u);
  template <class _E, class _U> executor_wrapper(_E&& __e, _U&& __u, true_type);
  template <class _E, class _U> executor_wrapper(_E&& __e, _U&& __u, false_type);
};

template <class _T, class _Executor>
  struct uses_executor<executor_wrapper<_T, _Executor>, _Executor> : true_type {};

template <class _T, class _Executor, class _Signature>
  struct handler_type<executor_wrapper<_T, _Executor>, _Signature>;

template <class _T, class _Executor>
  class async_result<executor_wrapper<_T, _Executor>>;

// An object of class executor_work controls ownership of executor work within
// a scope.

template <class _Executor>
class executor_work
{
public:
  typedef _Executor executor_type;

  // construct / copy / destroy:

  explicit executor_work(const executor_type& __e) noexcept;
  executor_work(const executor_work& __w) noexcept;
  executor_work(executor_work&& __w) noexcept;

  executor_work operator=(const executor_type&) = delete;

  ~executor_work();

  // executor work operations:

  executor_type get_executor() const noexcept;
  void reset() noexcept;

private:
  executor_type _M_executor;
  bool _M_owns;
};

// The system executor represents an execution context where functions are
// permitted to run on arbitrary threads. The post() function schedules the
// function to run on an unspecified system thread pool, and dispatch() invokes
// the function immediately.

class system_executor
{
public:
  // executor operations:

  execution_context& context() noexcept;

  void work_started() noexcept;
  void work_finished() noexcept;

  template <class _Func, class _Alloc>
    void dispatch(_Func&& __f, const _Alloc& a);
  template <class _Func, class _Alloc>
    void post(_Func&& __f, const _Alloc& a);
  template <class _Func, class _Alloc>
    void defer(_Func&& __f, const _Alloc& a);

  template <class _Func>
    executor_wrapper<typename decay<_Func>::type, system_executor>
      wrap(_Func&& __f) const;
};

bool operator==(const system_executor&, const system_executor&) noexcept;
bool operator!=(const system_executor&, const system_executor&) noexcept;

template <> struct is_executor<system_executor> : true_type {};

// The unspecified executor is used for function objects that do not explicitly
// specify an associated executor. It is implemented in terms of the system
// executor.

class unspecified_executor
{
public:
  // executor operations:

  execution_context& context() noexcept;

  void work_started() noexcept;
  void work_finished() noexcept;

  template <class _Func, class _Alloc>
    void dispatch(_Func&& __f, const _Alloc& a);
  template <class _Func, class _Alloc>
    void post(_Func&& __f, const _Alloc& a);
  template <class _Func, class _Alloc>
    void defer(_Func&& __f, const _Alloc& a);

  template <class _Func>
    executor_wrapper<typename decay<_Func>::type, unspecified_executor>
      wrap(_Func&& __f) const;
};

bool operator==(const unspecified_executor&, const unspecified_executor&) noexcept;
bool operator!=(const unspecified_executor&, const unspecified_executor&) noexcept;

template <> struct is_executor<unspecified_executor> : true_type {};

// Function to obtain an object's associated executor. For function objects,
// this is the executor that would be used to invoke the given function. This
// default implementation behaves as follows:
//
// - if the object type has a nested type @c executor_type, returns the
//   result of the object's @c get_executor() member function;
//
// - if the object is callable, returns an @c unspecified_executor object;
//
// - otherwise, this function does not participate in overload resolution.

template <class _T> typename __get_executor_impl<_T>::_Type
  get_executor(const _T&) noexcept;

class bad_executor;

// Polymorphic executor wrapper.

class executor
{
public:
  // construct / copy / destroy:

  executor() noexcept;
  executor(nullptr_t) noexcept;
  executor(const executor& __e) noexcept;
  executor(executor&& __e) noexcept;
  template <class _Executor> executor(_Executor __e);
  template <class _Executor, class _Alloc>
    executor(allocator_arg_t, const _Alloc& __a, _Executor __e);

  executor& operator=(const executor& __e) noexcept;
  executor& operator=(executor&& __e) noexcept;
  executor& operator=(nullptr_t) noexcept;
  template <class _Executor> executor& operator=(_Executor __e);

  ~executor();

  // executor operations:

  execution_context& context() noexcept;

  void work_started() noexcept;
  void work_finished() noexcept;

  template <class _Func, class _Alloc>
    void dispatch(_Func&& __f, const _Alloc& a);
  template <class _Func, class _Alloc>
    void post(_Func&& __f, const _Alloc& a);
  template <class _Func, class _Alloc>
    void defer(_Func&& __f, const _Alloc& a);

  template <class _Func>
    executor_wrapper<typename decay<_Func>::type, executor>
      wrap(_Func&& __f) const;

  // executor capacity:

  explicit operator bool() const noexcept;

  // executor target access:

  const type_info& target_type() const noexcept;
  template <class _Executor> _Executor* target() noexcept;
  template <class _Executor> const _Executor* target() const noexcept;

private:
  friend bool operator==(const executor&, const executor&) noexcept;
  explicit executor(__executor_impl_base* __i) : _M_impl(__i) {}
  __executor_impl_base* _M_impl;
};

template <> struct is_executor<executor> : true_type {};

bool operator==(const executor& __a, const executor& __b) noexcept;
bool operator==(const executor& __e, nullptr_t) noexcept;
bool operator==(nullptr_t, const executor& __e) noexcept;
bool operator!=(const executor& __a, const executor& __b) noexcept;
bool operator!=(const executor& __e, nullptr_t) noexcept;
bool operator!=(nullptr_t, const executor& __e) noexcept;

// Create a continuation function object from a list of completion tokens.

template <class... _CompletionTokens>
  auto chain(_CompletionTokens&&... __tokens);
template <class _Signature, class... _CompletionTokens>
  auto chain(_CompletionTokens&&... __tokens);

// Schedule a function to run now if possible, later otherwise.

template <class... _CompletionTokens>
  typename __invoke_with_token<_CompletionTokens...>::_Result
    dispatch(_CompletionTokens&&... __tokens);
template <class _Executor, class... _CompletionTokens>
  typename __invoke_with_executor<_Executor, _CompletionTokens...>::_Result
    dispatch(const _Executor& __e, _CompletionTokens&&... __tokens);
template <class _ExecutionContext, class... _CompletionTokens>
  typename __invoke_with_execution_context<_ExecutionContext, _CompletionTokens...>::_Result
    dispatch(_ExecutionContext& __c, _CompletionTokens&&... __tokens);

// Schedule a function to run later.

template <class... _CompletionTokens>
  typename __invoke_with_token<_CompletionTokens...>::_Result
    post(_CompletionTokens&&... __tokens);
template <class _Executor, class... _CompletionTokens>
  typename __invoke_with_executor<_Executor, _CompletionTokens...>::_Result
    post(const _Executor& __e, _CompletionTokens&&... __tokens);
template <class _ExecutionContext, class... _CompletionTokens>
  typename __invoke_with_execution_context<_ExecutionContext, _CompletionTokens...>::_Result
    post(_ExecutionContext& __c, _CompletionTokens&&... __tokens);

// Schedule a function to run later, treating the function as a continuation of the caller.

template <class... _CompletionTokens>
  typename __invoke_with_token<_CompletionTokens...>::_Result
    defer(_CompletionTokens&&... __tokens);
template <class _Executor, class... _CompletionTokens>
  typename __invoke_with_executor<_Executor, _CompletionTokens...>::_Result
    defer(const _Executor& __e, _CompletionTokens&&... __tokens);
template <class _ExecutionContext, class... _CompletionTokens>
  typename __invoke_with_execution_context<_ExecutionContext, _CompletionTokens...>::_Result
    defer(_ExecutionContext& __c, _CompletionTokens&&... __tokens);

// Schedule functions to run now if possible, run concurrently later otherwise.

template <class... _CompletionTokens>
  typename __coinvoke_without_executor<_CompletionTokens...>::_Result
    codispatch(_CompletionTokens&&... __tokens);
template <class _Executor, class... _CompletionTokens>
  typename __coinvoke_with_executor<_Executor, _CompletionTokens...>::_Result
    codispatch(const _Executor& __e, _CompletionTokens&&... __tokens);

// Schedule functions to run concurrently later.

template <class... _CompletionTokens>
  typename __coinvoke_without_executor<_CompletionTokens...>::_Result
    copost(_CompletionTokens&&... __tokens);
template <class _Executor, class... _CompletionTokens>
  typename __coinvoke_with_executor<_Executor, _CompletionTokens...>::_Result
    copost(const _Executor& __e, _CompletionTokens&&... __tokens);

// Schedule functions to run concurrently later.

template <class... _CompletionTokens>
  typename __coinvoke_without_executor<_CompletionTokens...>::_Result
    codefer(_CompletionTokens&&... __tokens);
template <class _Executor, class... _CompletionTokens>
  typename __coinvoke_with_executor<_Executor, _CompletionTokens...>::_Result
    codefer(const _Executor& __e, _CompletionTokens&&... __tokens);

} // inline namespace concurrency_v1
} // namespace experimental

template<class _Alloc>
  struct uses_allocator<std::experimental::executor, _Alloc>
    : true_type {};

} // namespace std

#include <experimental/bits/execution_context.h>
#include <experimental/bits/system_executor.h>
#include <experimental/bits/unspecified_executor.h>
#include <experimental/bits/get_executor.h>
#include <experimental/bits/executor_wrapper.h>
#include <experimental/bits/executor_work.h>
#include <experimental/bits/executor.h>
#include <experimental/bits/chain.h>
#include <experimental/bits/dispatch.h>
#include <experimental/bits/post.h>
#include <experimental/bits/defer.h>
#include <experimental/bits/codispatch.h>
#include <experimental/bits/copost.h>
#include <experimental/bits/codefer.h>

#endif
