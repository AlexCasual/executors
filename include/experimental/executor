//
// executor
// ~~~~~~~~
// Polymorphic executor wrapper and generic executor utility functions.
//
// Copyright (c) 2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef EXECUTORS_EXPERIMENTAL_EXECUTOR_HEADER
#define EXECUTORS_EXPERIMENTAL_EXECUTOR_HEADER

#include <experimental/type_traits>
#include <memory>
#include <mutex>
#include <scoped_allocator>
#include <typeinfo>
#include <utility>

namespace std {
namespace experimental {

class __executor_impl_base;
template <class> class __executor_impl;
class __work_impl_base;
template <class> class __work_impl;

// Execution context.

class execution_context
{
public:
  class service;

  // construct / copy / destroy:

  execution_context();
  execution_context(const execution_context&) = delete;
  execution_context& operator=(const execution_context&) = delete;
  virtual ~execution_context();

protected:

  // execution context operations:

  void shutdown();

private:
  template <class _Service> friend _Service& use_service(execution_context& __c);
  template <class _Service, class... _Args> friend _Service&
    make_service(execution_context& __c, _Args&&... __args);
  template <class _Service> bool friend has_service(execution_context& __c) noexcept;
  mutex _M_mutex;
  service* _M_first_service;
};

void get_executor(execution_context&) = delete;
void get_executor(const execution_context&) = delete;

// Base class for all services within an execution context.

class execution_context::service
{
protected:
  explicit service(execution_context& __c);
  virtual ~service();

  execution_context& context();

private:
  virtual void shutdown_service() = 0;

  friend class execution_context;
  template <class _Service> friend _Service& use_service(execution_context& __c);
  template <class _Service, class... _Args> friend _Service&
    make_service(execution_context& __c, _Args&&... __args);
  template <class _Service> bool friend has_service(execution_context& __c) noexcept;
  friend struct default_delete<service>;
  execution_context& _M_context;
  const type_info* _M_id;
  service* _M_next;
};

// Functions for accessing the services within an execution context.

class service_already_exists;

template <class _Service> _Service& use_service(execution_context& __c);
template <class _Service, class... _Args> _Service&
  make_service(execution_context& __c, _Args&&... __args);
template <class _Service> bool has_service(execution_context& __c) noexcept;

// The system executor represents an execution context where functions are
// permitted to run on arbitrary threads. The post() function schedules the
// function to run on an unspecified system thread pool, and dispatch() invokes
// the function immediately.

class system_executor
{
public:
  class work {};

  // executor operations:

  template <class _Func> void post(_Func&& __f);
  template <class _Func> void dispatch(_Func&& __f);
  work make_work();
  template <class _Func> auto wrap(_Func&& __f);
  execution_context& context();
};

// Obtain associated executor.

template <class _T> system_executor get_executor(const _T&);
system_executor get_executor(const system_executor&);
system_executor get_executor(system_executor&&);
system_executor get_executor(const system_executor::work&);
system_executor get_executor(system_executor::work&&);

class bad_executor;

// Polymorphic executor wrapper.

class executor
{
public:
  class work;

  // construct / copy / destroy:

  executor() noexcept;
  executor(nullptr_t) noexcept;
  executor(const executor& __e);
  executor(executor&& __e);
  template <class _Executor> executor(_Executor __e);
  template <class _Alloc> executor(allocator_arg_t, const _Alloc&) noexcept;
  template <class _Alloc> executor(allocator_arg_t, const _Alloc&, nullptr_t) noexcept;
  template <class _Alloc> executor(allocator_arg_t, const _Alloc&, const executor& __e);
  template <class _Alloc> executor(allocator_arg_t, const _Alloc&, executor&& __e);
  template <class _Executor, class _Alloc>
    executor(allocator_arg_t, const _Alloc& __a, _Executor __e);

  executor& operator=(const executor& __e);
  executor& operator=(executor&& __e);
  executor& operator=(nullptr_t);
  template <class _Executor> executor& operator=(_Executor&& __e);

  ~executor();

  // executor operations:

  template <class _Func> void post(_Func&& __f);
  template <class _Func> void dispatch(_Func&& __f);
  work make_work();
  template <class _Func> auto wrap(_Func&& __f);
  execution_context& context();

  // executor capacity:

  explicit operator bool() const noexcept;

  // executor target access:

  const type_info& target_type() const noexcept;
  template <class _Executor> _Executor* target() noexcept;
  template <class _Executor> const _Executor* target() const noexcept;

private:
  friend executor get_executor(const executor::work& __w);
  friend executor get_executor(executor::work&& __w);
  explicit executor(__executor_impl_base* __i) : _M_impl(__i) {}
  __executor_impl_base* _M_impl;
};

executor get_executor(const executor& __e);
executor get_executor(executor&& __e);

bool operator==(const executor& __e, nullptr_t) noexcept;
bool operator==(nullptr_t, const executor& __e) noexcept;
bool operator!=(const executor& __e, nullptr_t) noexcept;
bool operator!=(nullptr_t, const executor& __e) noexcept;

class executor::work
{
public:
  // construct / copy / destroy:

  work() noexcept;
  work(nullptr_t) noexcept;
  work(const work& __w);
  work(work&& __w);
  template <class _Work> work(_Work __w);
  template <class _Alloc> work(allocator_arg_t, const _Alloc&) noexcept;
  template <class _Alloc> work(allocator_arg_t, const _Alloc&, nullptr_t) noexcept;
  template <class _Alloc> work(allocator_arg_t, const _Alloc&, const work& __w);
  template <class _Alloc> work(allocator_arg_t, const _Alloc&, work&& __w);
  template <class _Work, class _Alloc>
    work(allocator_arg_t, const _Alloc& __a, _Work __w);

  work& operator=(const work& __w);
  work& operator=(work&& __w);
  work& operator=(nullptr_t);
  template <class _Work> work& operator=(_Work&& __w);

  ~work();

  // work capacity:

  explicit operator bool() const noexcept;

private:
  friend class executor;
  friend executor get_executor(const executor::work& __w);
  friend executor get_executor(executor::work&& __w);
  __work_impl_base* _M_impl;
  explicit work(__work_impl_base* __i) : _M_impl(__i) {}
};

executor get_executor(const executor::work& __w);
executor get_executor(executor::work&& __w);

bool operator==(const executor::work& __w, nullptr_t) noexcept;
bool operator==(nullptr_t, const executor::work& __w) noexcept;
bool operator!=(const executor::work& __w, nullptr_t) noexcept;
bool operator!=(nullptr_t, const executor::work& __w) noexcept;

// Schedule a function to run later.

template <class _Func> void post(_Func&& __f);
template <class _Func, class _CompletionToken>
  auto post(_Func&& __f, _CompletionToken&& __token);
template <class _Func, class _Executor, class _CompletionToken>
  auto post(_Func&& __f, _Executor&& __e, _CompletionToken&& __token);

// Schedule a function to run now if possible, later otherwise.

template <class _Func> void dispatch(_Func&& __f);
template <class _Func, class _CompletionToken>
  auto dispatch(_Func&& __f, _CompletionToken&& __token);
template <class _Func, class _Executor, class _CompletionToken>
  auto dispatch(_Func&& __f, _Executor&& __e, _CompletionToken&& __token);

} // namespace experimental

template<class _Alloc>
  struct uses_allocator<std::experimental::executor::work, _Alloc>
    : true_type {};

template<class _Alloc>
  struct uses_allocator<std::experimental::executor, _Alloc>
    : true_type {};

} // namespace std

#include <experimental/bits/execution_context.h>
#include <experimental/bits/system_executor.h>
#include <experimental/bits/executor.h>
#include <experimental/bits/post.h>
#include <experimental/bits/dispatch.h>

#endif
