//
// executor
// ~~~~~~~~
// Polymorphic executor wrapper and generic executor utility functions.
//
// Copyright (c) 2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef EXECUTORS_EXPERIMENTAL_EXECUTOR_HEADER
#define EXECUTORS_EXPERIMENTAL_EXECUTOR_HEADER

#include <experimental/bits/executor_wrapper_base.h>
#include <experimental/bits/function_traits.h>
#include <experimental/type_traits>
#include <memory>
#include <mutex>
#include <scoped_allocator>
#include <typeinfo>
#include <utility>

namespace std {
namespace experimental {

class __executor_impl_base;
template <class> class __executor_impl;
class __work_impl_base;
template <class> class __work_impl;

template <class...> struct __invoke_without_executor;
template <class, class...> struct __invoke_with_executor;
template <class...> struct __coinvoke_without_executor;
template <class, class...> struct __coinvoke_with_executor;
template <size_t, class...> struct __coinvoke_n_without_executor;
template <size_t, class, class...> struct __coinvoke_n_with_executor;

// Execution context.

class execution_context
{
public:
  class service;

  // construct / copy / destroy:

  execution_context();
  execution_context(const execution_context&) = delete;
  execution_context& operator=(const execution_context&) = delete;
  virtual ~execution_context();

protected:

  // execution context operations:

  void shutdown();

private:
  template <class _Service> friend _Service& use_service(execution_context& __c);
  template <class _Service, class... _Args> friend _Service&
    make_service(execution_context& __c, _Args&&... __args);
  template <class _Service> bool friend has_service(execution_context& __c) noexcept;
  mutex _M_mutex;
  service* _M_first_service;
};

void make_executor(execution_context&) = delete;
void make_executor(const execution_context&) = delete;

// Base class for all services within an execution context.

class execution_context::service
{
protected:
  explicit service(execution_context& __c);
  virtual ~service();

  execution_context& context();

private:
  virtual void shutdown_service() = 0;

  friend class execution_context;
  template <class _Service> friend _Service& use_service(execution_context& __c);
  template <class _Service, class... _Args> friend _Service&
    make_service(execution_context& __c, _Args&&... __args);
  template <class _Service> bool friend has_service(execution_context& __c) noexcept;
  friend struct default_delete<service>;
  execution_context& _M_context;
  const type_info* _M_id;
  service* _M_next;
};

// Functions for accessing the services within an execution context.

class service_already_exists;

template <class _Service> _Service& use_service(execution_context& __c);
template <class _Service, class... _Args> _Service&
  make_service(execution_context& __c, _Args&&... __args);
template <class _Service> bool has_service(execution_context& __c) noexcept;

// The is_executor trait detects whether _T meets the Executor type
// requirements. Meets the UnaryTypeTrait requirements. The implementation
// shall provide a definition that is derived from false_type. A program may
// specialize this template to derive from true_type for a user-defined type _T
// the meets the Executor requirements.

template <class _T> struct is_executor : false_type {};

// The executor_arg_t struct is an empty structure type used as a unique type
// to disambiguate constructor and function overloading. Specifically, some
// types have constructors with executor_arg_t as the first argument,
// immediately followed by an argument of a type that satisfies the Executor
// requirements.

struct executor_arg_t {};
constexpr executor_arg_t executor_arg = executor_arg_t{};

// The uses_executor trait detects whether _T has an associated executor that
// is convertible from type _Executor. Meets the BinaryTypeTrait requirements.
// The implementation shall provide a definition that is derived from
// false_type. A program may specialize this template to derive from true_type
// for a user-defined type _T that can be constructed with an executor, where
// the first argument of a constructor has type executor_arg_t and the second
// argument is convertible from type _Executor.

template <class _T, class _Executor> struct uses_executor : false_type {};

// A call wrapper type to associate an object of type _T with an executor of
// type _Executor.

template <class _T, class _Executor>
class executor_wrapper
  : public __executor_wrapper_base_executor<_Executor>,
    public __executor_wrapper_base_wrapped<_T>
{
public:
  // construct / copy / destroy:

  executor_wrapper(const executor_wrapper& __w);
  executor_wrapper(executor_wrapper&& __w);
  template <class _U> executor_wrapper(const executor_wrapper<_U, _Executor>& __w);
  template <class _U> executor_wrapper(executor_wrapper<_U, _Executor>&& __w);
  template <class _U> executor_wrapper(executor_arg_t, const _Executor& __e, _U&& __u);
  executor_wrapper(executor_arg_t, const _Executor& __e, const executor_wrapper& __w);
  executor_wrapper(executor_arg_t, const _Executor& __e, executor_wrapper&& __w);
  template <class _U> executor_wrapper(executor_arg_t, const _Executor& __e,
    const executor_wrapper<_U, _Executor>& __w);
  template <class _U> executor_wrapper(executor_arg_t, const _Executor& __e,
    executor_wrapper<_U, _Executor>&& __w);

  ~executor_wrapper();

  // executor wrapper operations:

  friend _Executor make_executor(const executor_wrapper& __w) { return __w._M_executor; }

private:
  template <class _U, class _E> friend class executor_wrapper;
  friend class async_result<executor_wrapper>;
  template <class _E, class _U> executor_wrapper(_E&& __e, _U&& __u);
  template <class _E, class _U> executor_wrapper(_E&& __e, _U&& __u, true_type);
  template <class _E, class _U> executor_wrapper(_E&& __e, _U&& __u, false_type);
};

template <class _T, class _Executor>
  struct uses_executor<executor_wrapper<_T, _Executor>, _Executor> : true_type {};

template <class _T, class _Executor, class _Signature>
  struct handler_type<executor_wrapper<_T, _Executor>, _Signature>;

template <class _T, class _Executor>
  class async_result<executor_wrapper<_T, _Executor>>;

// Associate an object of type _T with an executor of type _Executor. If
// uses_executor<_T, _Executor>::value is false, returns an object of type
// executor_wrapper<_T, _Executor>. Otherwise, returns a copy of __t
// constructed as _T(executor_arg, __e, __t).

template <class _T, class _Executor>
  auto wrap_with_executor(_T&& __t, const _Executor& __e);

// The system executor represents an execution context where functions are
// permitted to run on arbitrary threads. The post() function schedules the
// function to run on an unspecified system thread pool, and dispatch() invokes
// the function immediately.

class system_executor
{
public:
  class work {};

  // executor operations:

  template <class _Func> void post(_Func&& __f);
  template <class _Func> void dispatch(_Func&& __f);
  work make_work();
  template <class _Func> auto wrap(_Func&& __f);
  execution_context& context();
};

template <> struct is_executor<system_executor> : true_type {};

system_executor make_executor(const system_executor&);
system_executor make_executor(system_executor&&);
system_executor make_executor(const system_executor::work&);
system_executor make_executor(system_executor::work&&);

// The unspecified executor is used for function objects that do not explicitly
// specify an associated executor. It is implemented in terms of the system
// executor.

class unspecified_executor
{
public:
  class work {};

  // executor operations:

  template <class _Func> void post(_Func&& __f);
  template <class _Func> void dispatch(_Func&& __f);
  work make_work();
  template <class _Func> auto wrap(_Func&& __f);
  execution_context& context();
};

template <> struct is_executor<unspecified_executor> : true_type {};

template <class _T> unspecified_executor make_executor(const _T&,
  typename enable_if<__is_callable<_T>::value>::type* = 0);

unspecified_executor make_executor(const unspecified_executor&);
unspecified_executor make_executor(unspecified_executor&&);
unspecified_executor make_executor(const unspecified_executor::work&);
unspecified_executor make_executor(unspecified_executor::work&&);

class bad_executor;

// Polymorphic executor wrapper.

class executor
{
public:
  class work;

  // construct / copy / destroy:

  executor() noexcept;
  executor(nullptr_t) noexcept;
  executor(const executor& __e);
  executor(executor&& __e);
  template <class _Executor> executor(_Executor __e);
  template <class _Alloc> executor(allocator_arg_t, const _Alloc&) noexcept;
  template <class _Alloc> executor(allocator_arg_t, const _Alloc&, nullptr_t) noexcept;
  template <class _Alloc> executor(allocator_arg_t, const _Alloc&, const executor& __e);
  template <class _Alloc> executor(allocator_arg_t, const _Alloc&, executor&& __e);
  template <class _Executor, class _Alloc>
    executor(allocator_arg_t, const _Alloc& __a, _Executor __e);

  executor& operator=(const executor& __e);
  executor& operator=(executor&& __e);
  executor& operator=(nullptr_t);
  template <class _Executor> executor& operator=(_Executor&& __e);

  ~executor();

  // executor operations:

  template <class _Func> void post(_Func&& __f);
  template <class _Func> void dispatch(_Func&& __f);
  work make_work();
  template <class _Func> auto wrap(_Func&& __f);
  execution_context& context();

  // executor capacity:

  explicit operator bool() const noexcept;

  // executor target access:

  const type_info& target_type() const noexcept;
  template <class _Executor> _Executor* target() noexcept;
  template <class _Executor> const _Executor* target() const noexcept;

private:
  friend executor make_executor(const executor::work& __w);
  friend executor make_executor(executor::work&& __w);
  explicit executor(__executor_impl_base* __i) : _M_impl(__i) {}
  __executor_impl_base* _M_impl;
};

template <> struct is_executor<executor> : true_type {};

executor make_executor(const executor& __e);
executor make_executor(executor&& __e);

bool operator==(const executor& __e, nullptr_t) noexcept;
bool operator==(nullptr_t, const executor& __e) noexcept;
bool operator!=(const executor& __e, nullptr_t) noexcept;
bool operator!=(nullptr_t, const executor& __e) noexcept;

class executor::work
{
public:
  // construct / copy / destroy:

  work() noexcept;
  work(nullptr_t) noexcept;
  work(const work& __w);
  work(work&& __w);
  template <class _Work> work(_Work __w);
  template <class _Alloc> work(allocator_arg_t, const _Alloc&) noexcept;
  template <class _Alloc> work(allocator_arg_t, const _Alloc&, nullptr_t) noexcept;
  template <class _Alloc> work(allocator_arg_t, const _Alloc&, const work& __w);
  template <class _Alloc> work(allocator_arg_t, const _Alloc&, work&& __w);
  template <class _Work, class _Alloc>
    work(allocator_arg_t, const _Alloc& __a, _Work __w);

  work& operator=(const work& __w);
  work& operator=(work&& __w);
  work& operator=(nullptr_t);
  template <class _Work> work& operator=(_Work&& __w);

  ~work();

  // work capacity:

  explicit operator bool() const noexcept;

private:
  friend class executor;
  friend executor make_executor(const executor::work& __w);
  friend executor make_executor(executor::work&& __w);
  __work_impl_base* _M_impl;
  explicit work(__work_impl_base* __i) : _M_impl(__i) {}
};

executor make_executor(const executor::work& __w);
executor make_executor(executor::work&& __w);

bool operator==(const executor::work& __w, nullptr_t) noexcept;
bool operator==(nullptr_t, const executor::work& __w) noexcept;
bool operator!=(const executor::work& __w, nullptr_t) noexcept;
bool operator!=(nullptr_t, const executor::work& __w) noexcept;

// Schedule a function to run later.

template <class... _CompletionTokens>
  typename __invoke_without_executor<_CompletionTokens...>::_Result
    post(_CompletionTokens&&... __tokens);
template <class _Executor, class... _CompletionTokens>
  typename __invoke_with_executor<_Executor, _CompletionTokens...>::_Result
    post(_Executor&& __e, _CompletionTokens&&... __tokens);

// Schedule a function to run now if possible, later otherwise.

template <class... _CompletionTokens>
  typename __invoke_without_executor<_CompletionTokens...>::_Result
    dispatch(_CompletionTokens&&... __tokens);
template <class _Executor, class... _CompletionTokens>
  typename __invoke_with_executor<_Executor, _CompletionTokens...>::_Result
    dispatch(_Executor&& __e, _CompletionTokens&&... __tokens);

// Schedule two functions to run concurrently later.

template <class... _CompletionTokens>
  typename __coinvoke_without_executor<_CompletionTokens...>::_Result
    copost(_CompletionTokens&&... __tokens);
template <class _Executor, class... _CompletionTokens>
  typename __coinvoke_with_executor<_Executor, _CompletionTokens...>::_Result
    copost(_Executor&& __e, _CompletionTokens&&... __tokens);
template <size_t _N, class... _CompletionTokens>
  typename __coinvoke_n_without_executor<_N, _CompletionTokens...>::_Result
    copost(_CompletionTokens&&... __tokens);
template <size_t _N, class _Executor, class... _CompletionTokens>
  typename __coinvoke_n_with_executor<_N, _Executor, _CompletionTokens...>::_Result
    copost(_Executor&& __e, _CompletionTokens&&... __tokens);

// Schedule two functions to run now if possible, run concurrently later otherwise.

template <class... _CompletionTokens>
  typename __coinvoke_without_executor<_CompletionTokens...>::_Result
    codispatch(_CompletionTokens&&... __tokens);
template <class _Executor, class... _CompletionTokens>
  typename __coinvoke_with_executor<_Executor, _CompletionTokens...>::_Result
    codispatch(_Executor&& __e, _CompletionTokens&&... __tokens);
template <size_t _N, class... _CompletionTokens>
  typename __coinvoke_n_without_executor<_N, _CompletionTokens...>::_Result
    codispatch(_CompletionTokens&&... __tokens);
template <size_t _N, class _Executor, class... _CompletionTokens>
  typename __coinvoke_n_with_executor<_N, _Executor, _CompletionTokens...>::_Result
    codispatch(_Executor&& __e, _CompletionTokens&&... __tokens);

} // namespace experimental

template<class _Alloc>
  struct uses_allocator<std::experimental::executor::work, _Alloc>
    : true_type {};

template<class _Alloc>
  struct uses_allocator<std::experimental::executor, _Alloc>
    : true_type {};

} // namespace std

#include <experimental/bits/execution_context.h>
#include <experimental/bits/system_executor.h>
#include <experimental/bits/unspecified_executor.h>
#include <experimental/bits/executor_wrapper.h>
#include <experimental/bits/executor.h>
#include <experimental/bits/post.h>
#include <experimental/bits/dispatch.h>
#include <experimental/bits/copost.h>
#include <experimental/bits/codispatch.h>

#endif
